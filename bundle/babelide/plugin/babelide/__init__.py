import os
import inspect
import os.path as osp
import subprocess
import sys
import re

try:
    from jinja2 import Environment, PackageLoader
except:
    pass

import vim

from babelide.utils import install_virtual_env
from babelide.utils import install_package

from babelide.plugins.base import BabelIDE_Base_Plugin
from babelide.plugins.html5 import BabelIDE_HTML5_Plugin

class IDEManager(object):
    """Docstring for BabelIDE_Manager """

    def __init__(self):
        """@todo: Constructor """

    def init(self, babelide_basedir):
        """Initialize the plugin

        """

        self.__basedir = babelide_basedir

        # setup workarea
        self.__workarea = osp.join(self.__basedir, 'workarea')
        if not osp.exists(self.__workarea):
            os.makedirs(self.__workarea)

        # check if the virtual env is setup
        self.__virtualenv_path = osp.join(babelide_basedir, 'pyenv')
        exit_on_init = False
        if not osp.exists(self.__virtualenv_path):
            install_virtual_env( babelide_basedir )
            exit_on_init = True
        
        self.__python_exe = osp.join(self.__virtualenv_path, 'bin', 'python')
        self.__easyinstall_exe = osp.join(self.__virtualenv_path, 'bin',
                'easy_install')

        self.update_packages()

        if exit_on_init:
            self.exit_on_init()


        self.tmpl_loader = Environment(loader=PackageLoader('babelide'),
                trim_blocks=True, lstrip_blocks=True)

        # setup global data structures
        self._plugins = []
        self._actions = {}
        self._mappings = []

        # load ide plugins
        self._loadBase()
        self._loadHTML5()

        # accumulate data for wrapper generation
        self._accumulate_plugin_functions()
        self._accumulate_plugin_actions()
        self._accumulate_plugin_mappings()

        # build vim script of plugin wrappers
        self._build_wrapper_file()

    def exit_on_init(self):
        """Exit after virtualenv created to allow for restarting vim's python
        runtime.

        """
        print('*'*80)
        print('    Please restart vim')
        print('*'*80)

        vim.command('exit()')

    def destroy(self):
        """This is a cleanup method that gets called on vim exit"""
        # remove autogenerated plugin wrapper file
        
        pass

    def update_packages(self, force=False):
        """Run python setup.py develop to install new packages

        :force: Force the update

        """
        touch_file = osp.join(self.__workarea, 'packagesupdated')

        if force:
            os.remove(touch_file)
    
        # update virtualenv with new packages, if necessary
        if not osp.exists(touch_file):
            proc = subprocess.Popen(
                    [self.__python_exe,
                        'setup.py',
                        'develop'])
            proc.wait()

            subprocess.Popen('touch {}'.format(touch_file), shell=True)

    def _loadBase(self):
        """Load the base functionality for the IDE"""
        self._plugins.append( BabelIDE_Base_Plugin(self) )

    def _loadHTML5(self):
        """Load the html5 plugin

        """
        self._plugins.append( BabelIDE_HTML5_Plugin(self) )

    def _accumulate_plugin_functions(self):
        """Accumulate the public functions that will be exposed to vimscript for
        the plugin objects

        """
        all_funcs = {}
        for plugin in self._plugins:

            def CC_func_name(fname):
                t = fname.replace('_','-').capitalize()
                func_name = 'Babel{}{}'.format(plugin.name,t)
                func_name = re.sub('(-|^)([a-z])', lambda p: p.group(2).upper(),
                        func_name)

                entry_point = '{}_{}'.format(plugin.name, fname)
                return '{}:{}'.format(func_name, entry_point)

            all_funcs.update( { CC_func_name(x[0]):x[1] 
                for x in inspect.getmembers(plugin, inspect.ismethod)} )
        
        self._exposed_funcs = {x:y for x,y in all_funcs.iteritems() if hasattr(y, 
            '__exposed__')}

        self._autocommands = {x:y for x,y in all_funcs.iteritems() if hasattr(y,
            '__autocmd__')}


    def _accumulate_plugin_mappings(self):
        """Accumulate key mappings from plugin objects

        """
        for plugin in self._plugins:
            self._mappings.extend(plugin.get_mappings())

    def _accumulate_plugin_actions(self):
        """Accumulate that the plugins expose
        """
        for plugin in self._plugins:
            self._actions.update(plugin.get_actions())

    def _build_wrapper_file(self):
        """Build the vimscript wrapper file to expose all the functionality
        :returns: @todo

        """
        gen_vimscript = osp.join(self.__workarea, 'autogen_vimscript.vim')

        if osp.exists(gen_vimscript):
            os.remove(gen_vimscript)

        with open(gen_vimscript, 'w') as f:

            autogen_template = self.tmpl_loader.get_template('autogen_vimscript.tplvim')

            template_data = {
                'manager': self,
                'functions': self._exposed_funcs,
                'autocommands': self._autocommands,
                'mappings': self._mappings
                }

            f.write( autogen_template.render(template_data) )

    def call_entry_point(self, entry_point, *args):
        """Call a function entry point from one of the plugins"""
        
        plugin_name, func = entry_point.split('_', 1)
        class_name = 'BabelIDE_{}_Plugin'.format(plugin_name)

        return_val = None

        for plugin in self._plugins:
            if plugin.__class__.__name__ == class_name:
                return_val = getattr(plugin, func)(*args)
        
        return return_val

    def get_action_list(self, filetype):
        """ Return the list of actions for a particular filetype"""
        return self._actions.get(filetype, {})



# setup main  ide manager singleton
BabelIDE_Manager = IDEManager()
